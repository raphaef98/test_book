{"title":"Lecture 6","markdown":{"yaml":{"title":"Lecture 6"},"headingText":"Review of \"brackets\"","containsRefs":false,"markdown":"\n\n\n\n\nIn this lecture we will continue our journey of Data Manipulation with pandas after reviewing some fundamental aspects of the syntax\n    \n1. [Review]\n    * [Review of \"brackets\"](#Review-of-\"brackets\")\n2. [Pandas]\n    * [Dealing with Missing Values](#Missing-Values)\n    * [Dealing with Duplicates](#Duplicate-Values)\n2. [Plot of the Day](#Plotting)\n    * boxplot\n\n\n\n\nIn Python, there are several types of brackets used for different purposes. Here's a brief review of the most commonly used brackets:\n\n1. Parentheses `( )`: Parentheses are used for grouping expressions, defining function parameters, and invoking functions. They are also used in mathematical expressions to indicate order of operations.\n\n2. Square brackets `[ ]`: Square brackets are primarily used for indexing and slicing operations on lists, tuples, and strings. They allow you to access individual elements or extract subsequences from these data types.\n\n3. Curly brackets or braces `{ }`: Curly brackets are used to define dictionaries, which are key-value pairs. Dictionaries store data in an unordered manner, and you can access or manipulate values by referencing their corresponding keys within the curly brackets.\n\n\nIt's important to note that the usage of these brackets may vary depending on the specific context or programming paradigm you're working with. Nonetheless, understanding their general purpose will help you navigate Python code effectively.\n\n##### Examples\n\nHere are a few examples of how each type of bracket is used in Python:\n\n1. Parentheses `( )`:\n   - Grouping expressions:\n     ```python\n     result = (2 + 3) * 4  \n     # Output: 20\n     ```\n   - Defining function parameters:\n     ```python\n     def greet(name):\n         print(\"Hello, \" + name + \"!\")\n\n     greet(\"Alice\")  \n     # Output: Hello, Alice!\n     ```\n   - Invoking functions:\n     ```python\n     result = max(5, 10)  \n     # Output: 10\n     ```\n\n2. Square brackets `[ ]`:\n   - Indexing and slicing:\n     ```python\n     my_list = [1, 2, 3, 4, 5]\n     print(my_list[0])      \n     # Output: 1\n     print(my_list[1:3])    \n     # Output: [2, 3]\n     ```\n   - Modifying list elements:\n     ```python\n     my_list = [1, 2, 3]\n     my_list[1] = 10\n     print(my_list)         \n     # Output: [1, 10, 3]\n     ```\n\n3. Curly brackets or braces `{ }`:\n   - Defining dictionaries:\n     ```python\n     my_dict = {\"name\": \"Alice\", \"age\": 25, \"city\": \"London\"}\n     print(my_dict[\"name\"])    \n     # Output: Alice\n     ```\n   - Modifying dictionary values:\n     ```python\n     my_dict = {\"name\": \"Alice\", \"age\": 25}\n     my_dict[\"age\"] = 30\n     print(my_dict)            \n     # Output: {'name': 'Alice', 'age': 30}\n     ```\n\n\nRemember that the usage of brackets can vary depending on the specific programming context, but these examples provide a general understanding of their usage in Python.\n\n### [Tasks](Lecture6_exercises.ipynb)\n\n### Data Manipulation with pandas\n\nWhile we have seen panda's ability to (i) mix data types (strings, numbers, categories, Boolean, ...) and (ii) refer to columns and rows by names, this library offers a lot more powerful tools for efficiently gaining insights from data, e.g.\n\n\n- deal with missing values\n\n\n\n\n\n\n\n### Missing Values\n\nMissing data occurs commonly in many data analysis applications. \nMost often they are a consequence of\n\n- data entry errors, or \n- unknown numbers, or\n- `groupby` operations, or\n- wrong mathematical operations (`1/0`, $\\sqrt{-1}$,$\\log(0)$, ...)\n- \"not applicable\" questions, or\n- ....\n\nFor data with float type, pandas uses the floating-point value `NaN` (Not a Number) to represent missing data.\n\nPandas refers to missing data as `NA`, which stands for *not available*.\n\nThe built-in Python `None` value is also treated as NA:\n\nRecall constructing a DataFrame from a dictionary of equal-length lists or NumPy arrays (Lecture 4).\nWhat if there were data entry errors or just unknown numbers\n\n(Note the annoying conversion of integers to float, a solution discussed [here](https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html))\n\n#### Filtering Out Missing Data\n\nThere are a few ways to filter out missing data. While you always have the option to do it by hand using `pandas.isna` and Boolean indexing, `dropna` can be helpful.\n\nWith DataFrame objects, there are different ways to remove missing data. You may want to drop rows or columns that are all `NA`, or only those rows or columns containing any `NA`s at all. `dropna` by default drops any row containing a missing value:\n\nPassing `how=\"all\"` will drop only rows that are all NA:\n\nTo drop columns in the same way, pass `axis=\"columns\"`:\n\nSuppose you want to keep only rows containing at most a certain number of missing observations. You can indicate this with the `thresh` argument:\n\n#### Filling In Missing Data\n\nRather than filtering out missing data (and potentially discarding other data along with it), you may want to fill in the “holes” in any number of ways. For most purposes, the fillna method is the workhorse function to use. Calling `fillna` with a constant replaces missing values with that value:\n\n\nCalling `fillna` with a dictionary, you can use a different fill value for each column:\n\nWith `fillna` you can do lots of other things such as simple data imputation using the median or mean statistics, at least for purely numeric data types:\n\nDifferent values for each column\n\n-------------------------\n### Duplicate Values\n\nDuplicate rows may be found in a DataFrame for any number of reasons. \n\n Removing duplicates in pandas can be useful in various scenarios, particularly when working with large datasets or performing data analysis. Here's a convincing example to illustrate its usefulness:\n\nLet's say you have a dataset containing sales transactions from an online store. Each transaction record consists of multiple columns, including customer ID, product ID, purchase date, and purchase amount. Due to various reasons such as system glitches or human errors, duplicate entries might exist in the dataset, meaning that multiple identical transaction records are present.\n\nIn such a scenario, removing duplicates becomes beneficial for several reasons:\n\n1. Accurate Analysis: Duplicate entries can skew your analysis and lead to incorrect conclusions. By removing duplicates, you ensure that each transaction is represented only once, providing more accurate insights and preventing inflated or biased results.\n\n2. Data Integrity: Duplicate entries consume unnecessary storage space and can make data management more challenging. By eliminating duplicates, you maintain data integrity and ensure a clean and organized dataset.\n\n3. Efficiency: When dealing with large datasets, duplicate records can significantly impact computational efficiency. Removing duplicates allows you to streamline your data processing operations, leading to faster analysis and improved performance.\n\n4. Unique Identifiers: Removing duplicates becomes crucial when working with columns that should contain unique values, such as customer IDs or product IDs. By eliminating duplicates, you ensure the integrity of these unique identifiers and prevent issues when performing joins or merging dataframes.\n\nTo remove duplicates in pandas, you can use the `drop_duplicates()` function. It identifies and removes duplicate rows based on specified columns or all columns in the dataframe, depending on your requirements.\n\nOverall, removing duplicates in pandas is essential for maintaining data accuracy, integrity, and efficiency, allowing you to derive meaningful insights and make informed decisions based on reliable data.\n\nThe DataFrame method `duplicated` returns a Boolean Series indicating whether each row is a duplicate \n\nRelatedly, `drop_duplicates` returns a DataFrame with rows where the `duplicated` array is `False` filtered out:\n\nBoth methods by default consider all of the columns; alternatively, you can specify any `subset` of them to detect duplicates.\n\n--------------------------\n\n##### Titanic data\n\nNotice that the age columns contains missing values, which is a big topic by itself in data science.\n\nHow should an aggregating react to and handle missing values? The default often is to ignore and exclude them from the computation, e.g.\n\nIn general, it is a good idea to diagnose how many missing values there are in each column. We can use some handy built-in support for this task:\n\n### [Tasks](Lecture6_exercises.ipynb)\n\nDropping or replacing NAs:\n\n---------------------------\n\n## Plotting\n\nThe \"plot type of the day\" is one of the most popular ones used to display data distributions, the **boxplot**.\n\n\n\nBoxplots, also known as **box-and-whisker plots**, are a statistical visualization tool that provides a concise summary of a dataset's distribution. They display key descriptive statistics and provide insights into the central tendency, variability, and skewness of the data. Here's a brief introduction and motivation for using boxplots:\n\n1. Structure of Boxplots:\n   Boxplots consist of a box and whiskers that represent different statistical measures of the data:\n   - The box represents the interquartile range (IQR), which spans from the lower quartile (25th percentile) to the upper quartile (75th percentile). The width of the box indicates the spread of the middle 50% of the data.\n   - A line (whisker) extends from each end of the box to show the minimum and maximum values within a certain range (often defined as 1.5 times the IQR).\n   - Points beyond the whiskers are considered outliers and plotted individually.\n\n2. Motivation for Using Boxplots:\n   Boxplots offer several benefits and are commonly used for the following reasons:\n   - Visualizing Data Distribution: Boxplots provide a concise overview of the distribution of a dataset. They show the skewness, symmetry, and presence of outliers, allowing for quick identification of key features.\n   - Comparing Groups: Boxplots enable easy visual comparison of multiple groups or categories. By placing side-by-side boxplots, you can assess differences in central tendency and variability between groups.\n   - Outlier Detection: Boxplots explicitly mark outliers, aiding in the identification of extreme values or data points that deviate significantly from the overall pattern.\n   - Data Summary: Boxplots summarize key statistics, including the median, quartiles, and range, providing a quick understanding of the dataset without the need for detailed calculations.\n   - Robustness: Boxplots are relatively robust to skewed or asymmetric data and can effectively handle datasets with outliers.\n\nBoxplots are widely used in various fields, including data analysis, exploratory data visualization, and statistical reporting. They offer a clear and concise representation of data distribution, making them a valuable tool for understanding and communicating the characteristics of a dataset.\n\nThe pandas way\n\nThe matplotlib way\n\n### Task\n\n- Create a boxplot for `gdpPercap` instead. What do you notice ? Are you happy with how the plot looks? Any \"trick\" you can think to make this more readable?\n\n- Advanced: can you create boxplots for `gdpPerCap` and `lifeExp` in one command?\n\n--------------------------\n\nFurther Reading:\n\n- [Python Plotting With Matplotlib Tutorial](https://realpython.com/python-matplotlib-guide/#:~:text=A%20Figure%20object%20is%20the,%E2%80%9D%20as%20we%20might%20expect).)\n","srcMarkdownNoYaml":"\n\n\n\n\nIn this lecture we will continue our journey of Data Manipulation with pandas after reviewing some fundamental aspects of the syntax\n    \n1. [Review]\n    * [Review of \"brackets\"](#Review-of-\"brackets\")\n2. [Pandas]\n    * [Dealing with Missing Values](#Missing-Values)\n    * [Dealing with Duplicates](#Duplicate-Values)\n2. [Plot of the Day](#Plotting)\n    * boxplot\n\n\n\n### Review of \"brackets\"\n\nIn Python, there are several types of brackets used for different purposes. Here's a brief review of the most commonly used brackets:\n\n1. Parentheses `( )`: Parentheses are used for grouping expressions, defining function parameters, and invoking functions. They are also used in mathematical expressions to indicate order of operations.\n\n2. Square brackets `[ ]`: Square brackets are primarily used for indexing and slicing operations on lists, tuples, and strings. They allow you to access individual elements or extract subsequences from these data types.\n\n3. Curly brackets or braces `{ }`: Curly brackets are used to define dictionaries, which are key-value pairs. Dictionaries store data in an unordered manner, and you can access or manipulate values by referencing their corresponding keys within the curly brackets.\n\n\nIt's important to note that the usage of these brackets may vary depending on the specific context or programming paradigm you're working with. Nonetheless, understanding their general purpose will help you navigate Python code effectively.\n\n##### Examples\n\nHere are a few examples of how each type of bracket is used in Python:\n\n1. Parentheses `( )`:\n   - Grouping expressions:\n     ```python\n     result = (2 + 3) * 4  \n     # Output: 20\n     ```\n   - Defining function parameters:\n     ```python\n     def greet(name):\n         print(\"Hello, \" + name + \"!\")\n\n     greet(\"Alice\")  \n     # Output: Hello, Alice!\n     ```\n   - Invoking functions:\n     ```python\n     result = max(5, 10)  \n     # Output: 10\n     ```\n\n2. Square brackets `[ ]`:\n   - Indexing and slicing:\n     ```python\n     my_list = [1, 2, 3, 4, 5]\n     print(my_list[0])      \n     # Output: 1\n     print(my_list[1:3])    \n     # Output: [2, 3]\n     ```\n   - Modifying list elements:\n     ```python\n     my_list = [1, 2, 3]\n     my_list[1] = 10\n     print(my_list)         \n     # Output: [1, 10, 3]\n     ```\n\n3. Curly brackets or braces `{ }`:\n   - Defining dictionaries:\n     ```python\n     my_dict = {\"name\": \"Alice\", \"age\": 25, \"city\": \"London\"}\n     print(my_dict[\"name\"])    \n     # Output: Alice\n     ```\n   - Modifying dictionary values:\n     ```python\n     my_dict = {\"name\": \"Alice\", \"age\": 25}\n     my_dict[\"age\"] = 30\n     print(my_dict)            \n     # Output: {'name': 'Alice', 'age': 30}\n     ```\n\n\nRemember that the usage of brackets can vary depending on the specific programming context, but these examples provide a general understanding of their usage in Python.\n\n### [Tasks](Lecture6_exercises.ipynb)\n\n### Data Manipulation with pandas\n\nWhile we have seen panda's ability to (i) mix data types (strings, numbers, categories, Boolean, ...) and (ii) refer to columns and rows by names, this library offers a lot more powerful tools for efficiently gaining insights from data, e.g.\n\n\n- deal with missing values\n\n\n\n\n\n\n\n### Missing Values\n\nMissing data occurs commonly in many data analysis applications. \nMost often they are a consequence of\n\n- data entry errors, or \n- unknown numbers, or\n- `groupby` operations, or\n- wrong mathematical operations (`1/0`, $\\sqrt{-1}$,$\\log(0)$, ...)\n- \"not applicable\" questions, or\n- ....\n\nFor data with float type, pandas uses the floating-point value `NaN` (Not a Number) to represent missing data.\n\nPandas refers to missing data as `NA`, which stands for *not available*.\n\nThe built-in Python `None` value is also treated as NA:\n\nRecall constructing a DataFrame from a dictionary of equal-length lists or NumPy arrays (Lecture 4).\nWhat if there were data entry errors or just unknown numbers\n\n(Note the annoying conversion of integers to float, a solution discussed [here](https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html))\n\n#### Filtering Out Missing Data\n\nThere are a few ways to filter out missing data. While you always have the option to do it by hand using `pandas.isna` and Boolean indexing, `dropna` can be helpful.\n\nWith DataFrame objects, there are different ways to remove missing data. You may want to drop rows or columns that are all `NA`, or only those rows or columns containing any `NA`s at all. `dropna` by default drops any row containing a missing value:\n\nPassing `how=\"all\"` will drop only rows that are all NA:\n\nTo drop columns in the same way, pass `axis=\"columns\"`:\n\nSuppose you want to keep only rows containing at most a certain number of missing observations. You can indicate this with the `thresh` argument:\n\n#### Filling In Missing Data\n\nRather than filtering out missing data (and potentially discarding other data along with it), you may want to fill in the “holes” in any number of ways. For most purposes, the fillna method is the workhorse function to use. Calling `fillna` with a constant replaces missing values with that value:\n\n\nCalling `fillna` with a dictionary, you can use a different fill value for each column:\n\nWith `fillna` you can do lots of other things such as simple data imputation using the median or mean statistics, at least for purely numeric data types:\n\nDifferent values for each column\n\n-------------------------\n### Duplicate Values\n\nDuplicate rows may be found in a DataFrame for any number of reasons. \n\n Removing duplicates in pandas can be useful in various scenarios, particularly when working with large datasets or performing data analysis. Here's a convincing example to illustrate its usefulness:\n\nLet's say you have a dataset containing sales transactions from an online store. Each transaction record consists of multiple columns, including customer ID, product ID, purchase date, and purchase amount. Due to various reasons such as system glitches or human errors, duplicate entries might exist in the dataset, meaning that multiple identical transaction records are present.\n\nIn such a scenario, removing duplicates becomes beneficial for several reasons:\n\n1. Accurate Analysis: Duplicate entries can skew your analysis and lead to incorrect conclusions. By removing duplicates, you ensure that each transaction is represented only once, providing more accurate insights and preventing inflated or biased results.\n\n2. Data Integrity: Duplicate entries consume unnecessary storage space and can make data management more challenging. By eliminating duplicates, you maintain data integrity and ensure a clean and organized dataset.\n\n3. Efficiency: When dealing with large datasets, duplicate records can significantly impact computational efficiency. Removing duplicates allows you to streamline your data processing operations, leading to faster analysis and improved performance.\n\n4. Unique Identifiers: Removing duplicates becomes crucial when working with columns that should contain unique values, such as customer IDs or product IDs. By eliminating duplicates, you ensure the integrity of these unique identifiers and prevent issues when performing joins or merging dataframes.\n\nTo remove duplicates in pandas, you can use the `drop_duplicates()` function. It identifies and removes duplicate rows based on specified columns or all columns in the dataframe, depending on your requirements.\n\nOverall, removing duplicates in pandas is essential for maintaining data accuracy, integrity, and efficiency, allowing you to derive meaningful insights and make informed decisions based on reliable data.\n\nThe DataFrame method `duplicated` returns a Boolean Series indicating whether each row is a duplicate \n\nRelatedly, `drop_duplicates` returns a DataFrame with rows where the `duplicated` array is `False` filtered out:\n\nBoth methods by default consider all of the columns; alternatively, you can specify any `subset` of them to detect duplicates.\n\n--------------------------\n\n##### Titanic data\n\nNotice that the age columns contains missing values, which is a big topic by itself in data science.\n\nHow should an aggregating react to and handle missing values? The default often is to ignore and exclude them from the computation, e.g.\n\nIn general, it is a good idea to diagnose how many missing values there are in each column. We can use some handy built-in support for this task:\n\n### [Tasks](Lecture6_exercises.ipynb)\n\nDropping or replacing NAs:\n\n---------------------------\n\n## Plotting\n\nThe \"plot type of the day\" is one of the most popular ones used to display data distributions, the **boxplot**.\n\n\n\nBoxplots, also known as **box-and-whisker plots**, are a statistical visualization tool that provides a concise summary of a dataset's distribution. They display key descriptive statistics and provide insights into the central tendency, variability, and skewness of the data. Here's a brief introduction and motivation for using boxplots:\n\n1. Structure of Boxplots:\n   Boxplots consist of a box and whiskers that represent different statistical measures of the data:\n   - The box represents the interquartile range (IQR), which spans from the lower quartile (25th percentile) to the upper quartile (75th percentile). The width of the box indicates the spread of the middle 50% of the data.\n   - A line (whisker) extends from each end of the box to show the minimum and maximum values within a certain range (often defined as 1.5 times the IQR).\n   - Points beyond the whiskers are considered outliers and plotted individually.\n\n2. Motivation for Using Boxplots:\n   Boxplots offer several benefits and are commonly used for the following reasons:\n   - Visualizing Data Distribution: Boxplots provide a concise overview of the distribution of a dataset. They show the skewness, symmetry, and presence of outliers, allowing for quick identification of key features.\n   - Comparing Groups: Boxplots enable easy visual comparison of multiple groups or categories. By placing side-by-side boxplots, you can assess differences in central tendency and variability between groups.\n   - Outlier Detection: Boxplots explicitly mark outliers, aiding in the identification of extreme values or data points that deviate significantly from the overall pattern.\n   - Data Summary: Boxplots summarize key statistics, including the median, quartiles, and range, providing a quick understanding of the dataset without the need for detailed calculations.\n   - Robustness: Boxplots are relatively robust to skewed or asymmetric data and can effectively handle datasets with outliers.\n\nBoxplots are widely used in various fields, including data analysis, exploratory data visualization, and statistical reporting. They offer a clear and concise representation of data distribution, making them a valuable tool for understanding and communicating the characteristics of a dataset.\n\nThe pandas way\n\nThe matplotlib way\n\n### Task\n\n- Create a boxplot for `gdpPercap` instead. What do you notice ? Are you happy with how the plot looks? Any \"trick\" you can think to make this more readable?\n\n- Advanced: can you create boxplots for `gdpPerCap` and `lifeExp` in one command?\n\n--------------------------\n\nFurther Reading:\n\n- [Python Plotting With Matplotlib Tutorial](https://realpython.com/python-matplotlib-guide/#:~:text=A%20Figure%20object%20is%20the,%E2%80%9D%20as%20we%20might%20expect).)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","number-sections":false,"output-file":"Lecture6.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":"cosmo","number-depth":1,"title":"Lecture 6"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"Lecture6.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"block-headings":true,"documentclass":"scrreprt","title":"Lecture 6"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}